# name: test/sql/peg_parser/struct_identifier.test
# description: Test lambda syntax in peg parser
# group: [peg_parser]

require autocomplete

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$copy integers to '__TEST_DIR__/integers.json.gz' (FORMAT JSON, COMPRESSION GZIP)$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$CREATE OR REPLACE TABLE t(      x VARCHAR USING COMPRESSION Dictionary );$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$select distinct on (types) types from (select vector_type(a) from test limit 8192) tbl(types)$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$create table data(id integer, value integer);$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$create table t2 (id int, v_map struct(foo integer[]));$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$ATTACH '__TEST_DIR__/encrypted.duckdb' AS encrypted (ENCRYPTION_KEY 'asdf');$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$insert into data (id, value) select 1$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT UNNEST({'a': 42, 'b': {'c': 88, 'd': 99}}, recursive := true)$TEST_PEG_PARSER$);

# Reserved keyword as explicit alias
statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT c2 as end;$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$CREATE TABLE big_tbl AS SELECT i, concat('thisisalongstring', i) as str FROM range(10000000) t(i);$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$select distinct on (a) b from (select s a, md5(s::text)) limit 10;$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$select distinct on (a) b from (select s a, md5(s::double)) limit 10;$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT histogram_exact((date '2000-01-01' + interval (n) days))$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT MAP{ 0 : 0 } FROM lineitem$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT l_returnflag,       map {   '0': case when sum(1) filter(l_orderkey <= 0) is null then 0 end,       '1000000': sum(1) filter(l_orderkey > 0 and l_orderkey <= 1000000),         '2000000': sum(1) filter(l_orderkey > 1000000 and l_orderkey <= 2000000),       '3000000': sum(1) filter(l_orderkey > 2000000 and l_orderkey <= 3000000),   '4000000': sum(1) filter(l_orderkey > 3000000 and l_orderkey <= 4000000),       '5000000': sum(1) filter(l_orderkey > 4000000 and l_orderkey <= 5000000),   '6000000': sum(1) filter(l_orderkey > 5000000 and l_orderkey <= 6000000)        } FROM lineitem GROUP BY l_returnflag ORDER BY l_returnflag$TEST_PEG_PARSER$);

# Non reserved keyword as implicit alias (should fail)
statement error
CALL check_peg_parser($TEST_PEG_PARSER$SELECT c2 after;$TEST_PEG_PARSER$);
----
Binder Error: Failed to parse query "SELECT c2 after;" - did not consume all tokens (got to token 2 - after)

# Non keyword as explicit alias
statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT c2 as foo;$TEST_PEG_PARSER$);

# Non keyword implicit alias
statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT c2 foo;$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT foo: c2;$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT c2 'foo';$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT c2, c1 FROM (SELECT a)$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT number1, number2 SIMILAR TO '0' as a;$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT number1, number2 SIMILAR TO '0' as 'a';$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT * SIMILAR TO '0' as 'a';$TEST_PEG_PARSER$);

statement ok
CALL check_peg_parser($TEST_PEG_PARSER$SELECT c2, c1 FROM ( SELECT * SIMILAR TO 'number(\d+)' AS 'c\1' FROM (SELECT 1 as number1, 2 as number2, 3 as end) );$TEST_PEG_PARSER$);
