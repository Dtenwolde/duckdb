import os
import subprocess
from datetime import datetime
import re

# File paths
sql_peg_file = 'sql.peg'
reserved_keywords_file = 'keywords/reserved_keywords.list'
unreserved_keywords_file = 'keywords/unreserved_keywords.list'
output_header_file = 'sql_grammar.hpp'
peglint_source_file = 'peglint.cc'
peglint_executable = 'peglint'

def read_keywords(file_path):
    """Read keywords from a file and return a set of keywords."""
    with open(file_path, 'r') as file:
        return {line.strip() for line in file if line.strip()}

def verify_keywords(reserved_keywords, unreserved_keywords):
    """Verify that there are no overlapping keywords and prune any ending with _P."""
    # Check for overlapping keywords
    common_keywords = reserved_keywords & unreserved_keywords
    if common_keywords:
        raise ValueError(f"Overlapping keywords found: {common_keywords}")

    # Prune keywords ending with _P by removing the _P suffix
    reserved_keywords = {kw[:-2] if kw.endswith('_P') else kw for kw in reserved_keywords}
    unreserved_keywords = {kw[:-2] if kw.endswith('_P') else kw for kw in unreserved_keywords}

    return reserved_keywords, unreserved_keywords

def generate_grammar_header(input_peg, output_header, reserved_keywords, unreserved_keywords):
    """Generate the output grammar header file with additional rules for ReservedKeyword and UnreservedKeyword."""
    script_name = os.path.basename(__file__)
    generation_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    with open(input_peg, 'r') as infile, open(output_header, 'w') as outfile:
        # Write a header indicating the file is generated
        outfile.write("//" + "=" * 58 + "\n")
        outfile.write(f"// This file was generated by the script: {script_name}\n")
        outfile.write(f"// Generation timestamp: {generation_time}\n")
        outfile.write("//\n")
        outfile.write("// DO NOT EDIT THIS FILE DIRECTLY.\n")
        outfile.write("// Instead, make changes to the .peg or .list files and \n"
                      "// then regenerate the grammar using generate_grammar.py.\n")
        outfile.write("//\n")
        outfile.write(f"// Input files used to generate this file:\n")
        outfile.write(f"//   - {input_peg}\n")
        outfile.write(f"//   - {reserved_keywords_file}\n")
        outfile.write(f"//   - {unreserved_keywords_file}\n")
        outfile.write("//" + "=" * 58 + "\n\n")

        # Start the header guard
        outfile.write("#pragma once\n")

        # Add the grammar rules as a string
        outfile.write("const char* sql_grammar = R\"grammar(\n")
        for line in infile:
            outfile.write(line)
        outfile.write("\n\n")

        # Add ReservedKeyword rule
        outfile.write("ReservedKeyword <-\n")
        reserved_rules = [f"    '{kw.upper()}'i" for kw in sorted(reserved_keywords)]
        outfile.write("    " + " /\n    ".join(reserved_rules) + "\n\n")

        # Add UnreservedKeyword rule
        outfile.write("UnreservedKeyword <-\n")
        unreserved_rules = [f"    '{kw.upper()}'i" for kw in sorted(unreserved_keywords)]
        outfile.write("    " + " /\n    ".join(unreserved_rules) + "\n")

        # End the grammar string
        outfile.write("\n)grammar\";\n\n")

def compile_peglint(peglint_source, output_executable):
    """Compile peglint.cc to create an executable."""
    compile_command = ['g++', '-std=c++17', peglint_source, '-o', output_executable, '-I.']
    result = subprocess.run(compile_command, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"Failed to compile peglint: {result.stderr}")

import re

def extract_grammar_from_hpp(hpp_file):
    """Extract the grammar content from the .hpp file."""
    with open(hpp_file, 'r') as file:
        content = file.read()

    # Regular expression to extract content between R"grammar(...)" markers
    grammar_regex = re.compile(r'\bR\"grammar\(([\s\S]*?)\)grammar\";', re.MULTILINE)
    match = grammar_regex.search(content)

    if not match:
        raise ValueError("Failed to extract grammar from the .hpp file")

    return match.group(1)

def run_peglint(hpp_file, peglint_exec):
    """Run the peglint executable to verify the grammar file."""
    # Extract grammar from the .hpp file
    try:
        grammar_content = extract_grammar_from_hpp(hpp_file)
    except ValueError as e:
        print(f"Error: {e}")
        return False

    # Write the extracted grammar to a temporary file for peglint
    temp_grammar_file = 'temp_sql.gram'
    with open(temp_grammar_file, 'w') as temp_file:
        temp_file.write(grammar_content)

    # Run peglint on the temporary grammar file
    lint_command = [peglint_exec, temp_grammar_file]
    result = subprocess.run(lint_command, capture_output=True, text=True)

    # Output whatever peglint returns
    print(result.stdout)
    if result.stderr:
        print(result.stderr)

    # Clean up the temporary file
    os.remove(temp_grammar_file)

    # Check the return code to determine if it passed or failed
    if result.returncode != 0:
        print("Peglint encountered errors.")
        return False
    else:
        print("Grammar verification passed with no errors.")
        return True

def main():
    # Step 1: Read keywords from files
    reserved_keywords = read_keywords(reserved_keywords_file)
    unreserved_keywords = read_keywords(unreserved_keywords_file)

    # Step 2: Verify keywords
    try:
        reserved_keywords, unreserved_keywords = verify_keywords(reserved_keywords, unreserved_keywords)
    except ValueError as e:
        print(f"Keyword verification failed: {e}")
        return

    # Step 3: Generate the output grammar header file
    generate_grammar_header(sql_peg_file, output_header_file, reserved_keywords, unreserved_keywords)

    # Step 4: Compile the peglint tool
    try:
        compile_peglint(peglint_source_file, peglint_executable)
    except RuntimeError as e:
        print(f"Compilation of peglint failed: {e}")
        return

    # Step 5: Run peglint to check the grammar file
    if run_peglint(output_header_file, peglint_executable):
        print("All clear: The grammar file is correct.")
    else:
        print("Grammar verification failed.")

if __name__ == '__main__':
    main()